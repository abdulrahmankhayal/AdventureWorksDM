USE [AdventureWorksDM]
GO

/****** Object:  StoredProcedure [dbo].[CreateETLLoggingRecord]    Script Date: 1/16/2023 9:33:37 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

/*
-- The procedure performs an INSERT statement into the "ETLRun" table with values for the following columns:
-- "TableName", "ChangeTracking_VersionNumber", "ETLStatus", "StartTime", "EndTime", and "RecordCount"

-- The "ChangeTracking_VersionNumber" and "EndTime" columns are set to NULL and the "ETLStatus" column is set to 'Running'
-- "StartTime" is set to current date using "getdate()".

-- After the insert statement, the stored procedure sets the value of the output parameter "@ETLID" to the scope identity generated by the INSERT statement
-- This allows the calling code to know the ID of the ETL run that was created.
*/
CREATE   PROCEDURE [dbo].[CreateETLLoggingRecord]
	@TableName varchar(200),
	@ETLID INT OUTPUT
AS
-- "@TableName" - a varchar(200) that is used to specify the name of the table being processed
-- "@ETLID" - an INT output parameter that is used to return the ID of the ETL run that was generated
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	--Insert a new record into the ETLRun table and return the ETLID that was generated
    INSERT INTO [ETLRun]
           ([TableName]
           ,[ChangeTracking_VersionNumber]
           ,[ETLStatus]
           ,[StartTime]
           ,[EndTime]
           ,[RecordCount])
     VALUES
           (@TableName
           ,NULL
           ,'Running'
           ,getdate()
           ,NULL
           ,NULL)

	SET @ETLID = SCOPE_IDENTITY();

END
GO


USE [AdventureWorksDM]
GO

/****** Object:  StoredProcedure [dbo].[Merge_DimCustomer]    Script Date: 1/16/2023 9:33:48 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE   PROCEDURE [dbo].[Merge_DimCustomer]
	@PackageStartTime datetime
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	Declare @RecordCount INT = 0;


	/*
	[Title]				= Type 1
	[FirstName]			= Type 1
	[MiddleName]		= Type 1
	[LastName]			= Type 1
	[PhoneNumber]		= Type 2
	[PhoneType]			= Type 2
	[HomeAddressLine1]	= Type 2
	[HomeAddressLine2]	= Type 2
	[HomeCity]			= Type 2
	[HomePostalCode]	= Type 2
	[HomeStateProvince] = Type 2
	[HomeCountryRegion] = Type 2
	*/


		--Type 1 changes
		MERGE INTO DimCustomer tgt
		USING stg_DimCustomer src ON tgt.nk_CustomerID = src.nk_CustomerID
		WHEN MATCHED AND EXISTS 
		(	
			select src.[Title],  src.[FirstName],  src.[LastName]	
			except 
			select tgt.[Title],   tgt.[FirstName], tgt.[LastName]	
		)
		THEN UPDATE
		SET 
			tgt.Title = src.Title,
			tgt.[FirstName] = src.[FirstName],
			tgt.[LastName]	= src.[LastName],
			tgt.DateUpdated = @PackageStartTime
		WHEN NOT MATCHED BY TARGET THEN INSERT
		(
			nk_CustomerID  ,
			nk_BusinessEntityID  ,
			nk_AddressID ,
			Title  ,
			FirstName  ,
			LastName  ,
			PhoneNumber ,
			PhoneType ,
			HomeAddressLine1 ,
			HomeAddressLine2 ,
			HomeCity ,
			HomePostalCode  ,
			HomeStateProvince ,
			HomeCountryRegion  ,
			current_flag,
			StartDate ,
			EndDate ,
			DateInserted ,
			DateUpdated 
		)
		VALUES
		(
			src.nk_CustomerID  ,
			src.nk_BusinessEntityID  ,
			src.nk_AddressID ,
			src.Title  ,
			src.FirstName  ,
			src.LastName  ,
			src.PhoneNumber ,
			src.PhoneType ,
			src.HomeAddressLine1 ,
			src.HomeAddressLine2 ,
			src.HomeCity ,
			src.HomePostalCode  ,
			src.HomeStateProvince ,
			src.HomeCountryRegion  ,
			'Y',
			@PackageStartTime
			,NULL
			,@PackageStartTime
			,@PackageStartTime
		);




		
	IF OBJECT_ID('tempdb..#DimCustomer') IS NOT NULL
    DROP TABLE #DimCustomer;

	CREATE TABLE #DimCustomer
	(
	nk_CustomerID INT NULL ,
	[nk_BusinessEntityID] [int] NULL,
	nk_AddressID INT NULL ,
	[Title] [nvarchar](50) NULL,
	[FirstName] [nvarchar](50) NULL,
	[LastName] [nvarchar](50) NULL,
	[PhoneNumber] nvarchar(25) NULL,
	[PrevPhoneNumber] nvarchar(25) NULL,
	[PhoneType] nvarchar(50) NULL,
	HomeAddressLine1 nvarchar(60) NULL ,
	HomeAddressLine2 nvarchar(60) NULL ,
	HomeCity nvarchar(30) NULL ,
	HomePostalCode nvarchar(15) NULL ,
	HomeStateProvince nvarchar(50) NULL ,
	HomeCountryRegion nvarchar(50) NULL ,
	current_flag char(1) Not NULL,
	StartDate datetime NULL,
	EndDate datetime NULL
	);


	--Type 2 Changes
	INSERT INTO #DimCustomer
		   (
		    nk_CustomerID  , nk_BusinessEntityID  , nk_AddressID ,Title  , FirstName  , LastName  , PhoneNumber , PhoneType ,
			HomeAddressLine1 , HomeAddressLine2 , HomeCity , HomePostalCode  , HomeStateProvince , HomeCountryRegion  ,current_flag, StartDate , EndDate )
	SELECT	nk_CustomerID  , nk_BusinessEntityID  , nk_AddressID ,Title  , FirstName  , LastName  , PhoneNumber , PhoneType ,
			HomeAddressLine1 , HomeAddressLine2 , HomeCity , HomePostalCode  , HomeStateProvince , HomeCountryRegion  , current_flag ,StartDate , EndDate
    From (
		MERGE INTO DimCustomer tgt
		USING stg_DimCustomer src ON tgt.nk_CustomerID = src.nk_CustomerID
		WHEN MATCHED AND tgt.EndDate IS NULL AND EXISTS 
		(	
			select src.[PhoneNumber], src.[PhoneType], src.[HomeAddressLine1], src.[HomeAddressLine2], src.[HomeCity], src.[HomePostalCode], src.[HomeStateProvince], src.[HomeCountryRegion]
			except 
			select tgt.[PhoneNumber], tgt.[PhoneType], tgt.[HomeAddressLine1], tgt.[HomeAddressLine2], tgt.[HomeCity], tgt.[HomePostalCode], tgt.[HomeStateProvince], tgt.[HomeCountryRegion]
		)
		THEN UPDATE
		SET current_flag ='N',
			tgt.EndDate = @PackageStartTime,
			tgt.DateUpdated = @PackageStartTime
WHEN NOT MATCHED BY TARGET THEN INSERT
		(
			nk_CustomerID  ,
			nk_BusinessEntityID  ,
			nk_AddressID ,
			Title  ,
			FirstName  ,
			LastName  ,
			PhoneNumber ,
			PhoneType ,
			HomeAddressLine1 ,
			HomeAddressLine2 ,
			HomeCity ,
			HomePostalCode  ,
			HomeStateProvince ,
			HomeCountryRegion  ,
			current_flag,
			StartDate ,
			EndDate ,
			DateInserted ,
			DateUpdated 
		)
		VALUES
		(
			src.nk_CustomerID  ,
			src.nk_BusinessEntityID  ,
			src.nk_AddressID ,
			src.Title  ,
			src.FirstName  ,
			src.LastName  ,
			src.PhoneNumber ,
			src.PhoneType ,
			src.HomeAddressLine1 ,
			src.HomeAddressLine2 ,
			src.HomeCity ,
			src.HomePostalCode  ,
			src.HomeStateProvince ,
			src.HomeCountryRegion  ,
			'Y',
			@PackageStartTime
			,NULL
			,@PackageStartTime
			,@PackageStartTime
		)
		Output $ACTION ActionOut,src.nk_CustomerID, src.[nk_BusinessEntityID],src.nk_AddressID, src.[Title], src.[FirstName],  src.[LastName], 
			src.[PhoneNumber], src.[PhoneType],src.HomeAddressLine1 ,src.HomeAddressLine2 ,src.HomeCity ,src.HomePostalCode  ,src.HomeStateProvince ,src.HomeCountryRegion  ,
			'Y' as current_flag, @PackageStartTime as StartDate, NULL as EndDate) AS MergeOut
	WHERE  MergeOut.ActionOut = 'UPDATE';


	/*
	We use a temp table, and then insert into the dimension table, to avoid this error message:
		"The target table 'TableName' of the INSERT statement cannot be on either side of a (primary key, foreign key) relationship 
		when the FROM clause contains a nested INSERT, UPDATE, DELETE, or MERGE statement. Found reference constraint 'ConstraintName'."

	This only applies if the dimension table has foreign key relationships defined
	*/
	insert into DimCustomer
			(
		    nk_CustomerID  , nk_BusinessEntityID  , nk_AddressID ,Title  , FirstName  , LastName  , PhoneNumber , PhoneType ,
			HomeAddressLine1 , HomeAddressLine2 , HomeCity , HomePostalCode  , HomeStateProvince , HomeCountryRegion  , current_flag , StartDate , EndDate )
	SELECT	nk_CustomerID  , nk_BusinessEntityID  , nk_AddressID ,Title  , FirstName  , LastName  , PhoneNumber , PhoneType ,
			HomeAddressLine1 , HomeAddressLine2 , HomeCity , HomePostalCode  , HomeStateProvince , HomeCountryRegion  , current_flag , StartDate , EndDate
	from #DimCustomer;


		--Save the number of records touched by the MERGE statement and send the results back to SSIS
		select COUNT(*) as RecordCount
		from DimCustomer 
		where DateInserted = @PackageStartTime or DateUpdated = @PackageStartTime;


	
END
GO

USE [AdventureWorksDM]
GO

/****** Object:  StoredProcedure [dbo].[Merge_FactSalesOrder]    Script Date: 1/16/2023 9:33:56 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE     PROCEDURE [dbo].[Merge_FactSalesOrder]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

		Declare @RecordCount INT = 0;

		--Merge from the staging table into the final dimension table
		MERGE INTO FactSalesOrder tgt
		USING stg_FactSalesOrder src ON tgt.SalesOrderDetailID = src.SalesOrderDetailID
		WHEN MATCHED
		THEN UPDATE
		SET 
			tgt.SalesOrderID = src.SalesOrderID,
			tgt.DateOrderKey = src.DateOrderKey,
			tgt.DateDueKey = src.DateDueKey,
			tgt.DateShipKey = src.DateShipKey,
			tgt.OnlineOrderFlag = src.OnlineOrderFlag,
			tgt.fk_CustomerKey = src.fk_CustomerKey,
			tgt.fk_SalesPersonKey = src.fk_SalesPersonKey,
			tgt.fk_ProductKey = src.fk_ProductKey,
			tgt.OrderQty = src.OrderQty,
			tgt.UnitPrice = src.UnitPrice,
			tgt.DiscountPct = src.DiscountPct,
			tgt.DiscountAmt = src.DiscountAmt,
			tgt.SalesAmt = src.SalesAmt,
			tgt.DateUpdated = getdate()
		WHEN NOT MATCHED BY TARGET THEN INSERT
		(
		    SalesOrderID ,
			SalesOrderDetailID ,
			DateOrderKey ,
			DateDueKey ,
			DateShipKey ,
			OnlineOrderFlag ,
			fk_CustomerKey ,
			fk_SalesPersonKey ,
			fk_ProductKey ,
			OrderQty ,
			UnitPrice ,
			DiscountPct ,
			DiscountAmt ,
			SalesAmt
		)
		VALUES
		(
			src.SalesOrderID ,
			src.SalesOrderDetailID ,
			src.DateOrderKey ,
			src.DateDueKey ,
			src.DateShipKey ,
			src.OnlineOrderFlag ,
			src.fk_CustomerKey ,
			src.fk_SalesPersonKey ,
			src.fk_ProductKey ,
			src.OrderQty ,
			src.UnitPrice ,
			src.DiscountPct ,
			src.DiscountAmt ,
			src.SalesAmt
		);

		--Save the number of records touched by the MERGE statement and send the results back to SSIS
		SET @RecordCount = @@ROWCOUNT;
		SELECT @RecordCount;
	
END
GO

USE [AdventureWorksDM]
GO

/****** Object:  StoredProcedure [dbo].[UpdateETLLoggingRecord]    Script Date: 1/16/2023 9:34:08 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO



CREATE   PROCEDURE [dbo].[UpdateETLLoggingRecord]
	@ETLID INT ,
	@ETLStatus varchar(25),
	@RecordCount INT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	--Insert a new record into the ETLRun table and return the ETLID that was generated
	update ETLRun 
	set	EndTime = getdate(),
		ETLStatus = @ETLStatus,
		RecordCount = @RecordCount
	where ETLRunKey = @ETLID;

END
GO

